/*
迷宫问题。假设迷宫由m行n列构成，有一个入口和一个出口，入口坐标为(1,1)，出口坐标为(m,n)，试设计并验证以下算法，找出一条从入口通往出口的路径，或报告一个"无法通过"
的信息。
(1)用c语言实现顺序存储结构上队列的基本操作，然后里利用该队列的基本操作找出迷宫的一条最短路径
(2)设计一个二维数组MAZE[m+2][n+2]表示迷宫，数组元素为0表示该位置可以通过，数组元素为1表示该位置不可以通行，MAZE[1][1]、MAZE[m][n]分别为迷宫的入口和出口
(3)输入迷宫的大小m行和n列，动态生成二维数组；由随机数产生0或1，建立迷宫注意m**n的迷宫需要进行扩展，扩展部分的元素设置为1，相当于在迷宫周围不上一圈不准通过的墙
(4)要求输入模拟迷宫的二维数组：若存在最短路径，则由出口会说到入口(出队列并利用栈实现)，再打印从入口到出口的这条路径,例如(1,1),......,(i,j),......,(m,n);
	若没有路径，则打印"No path"
(5)迷宫的任一位置(i,j)上均有八个可以移动的方向，用二维数组Dierction存放八个方向上的位置偏移量
	Direction[8][2] = {{0,1}, {1,1}, {1,0}, {1,-1}, {0,-1}, {-1,-1}, {-1,0}, {-1,1}};
(6)为避免出现原地踏步的情况，为了标志已经通过的位置，曹勇一个标志数组MAEK[m+2][n+2],初值均为0，在寻找路径的过程中，若通过了位置(i,j),则将MARK[i][j]置为1
(7)为了记录查找过程中到达位置(i,j)及首次到达(i,j)的前一位置(i_pre, j_pre)，需要记住前一位置(i_pre,j_pre)在队列中的序号pre，即队列中数据元素应该是一个三元组
	(i,j,pre)
(8)搜索过程简单描述如下：将入口MAZE[1][1]作为第一个出发点，依次在八哥方向上搜索可通行的位置，将可通行位置(i,j,pre)入队，形成第一层新的出发点，然后依次出队，
	即对第一层中各个位置分别搜索它所在八个方向上的可通行位置，形成第二层新的出发点，。。。，如此进行下去，直至达到出口MAZE[m][n]或者迷宫所有位置都搜索完毕为止	

思路：
1、初始化迷宫
2、找出最短路径，存到一个队列中
3、输出队列

*/
#include "Test4_2.h"

int main(void) {
	SqQueue Queue;
	Maze maze;
	int row = 0, col = 0;
	//设置迷宫大小
	printf("输入迷宫的大小 : \n");
	printf("row : ");
	scanf("%d", &row);
	printf("col : ");
	scanf("%d", &col);

	//初始化队列和迷宫，并打印迷宫
	InitQueue(&Queue);
	InitMaze(&maze, row, col);
	PrintMaze(maze);
	//找到最短路径
	SearchMostShortRoad(maze, &Queue);
	//打印路径
	PrintRoad(Queue);

	//销毁迷宫和队列
	DestroyMaze(&maze);
	DestroyQueue(&Queue);

	system("pause");
	return 0;
}